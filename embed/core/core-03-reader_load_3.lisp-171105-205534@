; Beginning of Licence
;
; This software is licensed only for personal and educational use and
; not for the production of commercial software.  Modifications to this
; program are allowed but the resulting source must be annotated to
; indicate the nature of and the author of these changes.  
;
; Any modified source is bound by this licence and must remain available 
; as open source under the same conditions it was supplied and with this 
; licence at the top.

; This software is supplied AS IS without any warranty.  In no way shall 
; Mark Tarver or Lambda Associates be held liable for any damages resulting 
; from the use of this program.

; The terms of these conditions remain binding unless the individual 
; holds a valid license to use Qi commercially.  This license is found 
; in the final page of 'Functional Programming in Qi'.  In that event 
; the terms of that license apply to the license holder. 
;
; (c) copyright Mark Tarver, 2008
; End of Licence

(eval-when (:compile-toplevel :load-toplevel :execute)
  (SETF *READTABLE* (COPY-READTABLE *READTABLE*))
  (SETF (READTABLE-CASE *READTABLE*) :PRESERVE)
  )

(IN-PACKAGE :xi.core)

;; JUN HACKED
;; ADDED 
(DEFPARAMETER *associative-right-operators* '(+ * and or append))
(DEFPARAMETER *associative-left-operators* '(- /))

(DEFUN associative-right (op-sym)
  (PUSHNEW op-sym *associative-right-operators*)
  op-sym)
(DEFUN associative-left (op-sym)
  (PUSHNEW op-sym *associative-left-operators*)
  op-sym)
(EXPORT 'associative-left)
(EXPORT 'associative-right)

;; JUN HACKED (DELETE)
;; (DEFUN associative? (V549)
;;  (COND ((EQ '+ V549) 'true) ((EQ '* V549) 'true) ((EQ 'and V549) 'true)
;;   ((EQ 'or V549) 'true) ((EQ 'append V549) 'true) (T 'false)))

;; JUN HACKED (ADDED)
;; 右結合の多引数演算子か？ {+ * etc...}
(DEFUN associative-right? (op)
  (IF (MEMBER op *associative-right-operators*)
    'true
    'false))

;; JUN HACKED (ADDED)
;; 左結合の多引数演算子か？ {- / etc...}
(DEFUN associative-left? (op)
  (IF (MEMBER op *associative-left-operators*)
    'true
    'false))


(DEFUN lineread NIL (lineread_loop (READ-CHAR) NIL))

(DEFUN lineread_loop (V3 V4)
 (COND ((EQL #\^ V3) (error "line read aborted"))
  ((MEMBER V3 (LIST #\Newline #\Return) :TEST 'CHAR-EQUAL)
   (LET ((Line (compile '<st_input> V4)))
    (IF (OR (EQ Line 'fail!) (NULL Line))
        (lineread_loop (READ-CHAR) (APPEND V4 (LIST V3)))
        Line)))
  (T (lineread_loop (READ-CHAR) (APPEND V4 (LIST V3))))))

(DEFUN read-file (V5)
 (LET
  ((ErrorString
    (FORMAT NIL "parse failure of file ~A here: ~~%~~%~~{~~C~~} ..." V5)))
  (LET ((Chars (read-file-as-charlist V5)))
       (compile '<st_input> Chars ErrorString))))

(DEFUN <st_input> (Stream)
 (OR
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\[))
    (LET
     ((<st_input1> (<st_input1> (LIST (REST (FIRST Stream)) (SECOND Stream)))))
     (IF (NOT (failure? <st_input1>))
      (IF
       (AND (CONSP (FIRST <st_input1>)) (EQL (FIRST (FIRST <st_input1>)) #\]))
       (LET
        ((<st_input2>
          (<st_input2>
           (LIST (REST (FIRST <st_input1>)) (SECOND <st_input1>)))))
        (IF (NOT (failure? <st_input2>))
         (LIST (FIRST <st_input2>)
          (CONS (user-syntax-in (cons_form (SECOND <st_input1>))) (SECOND <st_input2>)))
         NIL))
       NIL)
      NIL))
    NIL))
   (BLOCK localfailure
  (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\())
   (LET
    ((<st_input1> (<st_input1> (LIST (REST (FIRST Stream)) (SECOND Stream)))))
    (IF (NOT (failure? <st_input1>))
     (IF
      (AND (CONSP (FIRST <st_input1>)) (EQL (FIRST (FIRST <st_input1>)) #\)))
      (LET
       ((<st_input2>
         (<st_input2>
          (LIST (REST (FIRST <st_input1>)) (SECOND <st_input1>)))))
       (IF (NOT (failure? <st_input2>))
        (LIST (FIRST <st_input2>)
         (CONS (user-syntax-in (proc_specialforms (SECOND <st_input1>))) (SECOND <st_input2>)))
        NIL))
      NIL)
     NIL))
   NIL))
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\|))
    (LET
     ((<st_input> (<st_input> (LIST (REST (FIRST Stream)) (SECOND Stream)))))
     (IF (NOT (failure? <st_input>))
      (LIST (FIRST <st_input>) (CONS 'bar# (SECOND <st_input>))) NIL))
    NIL))
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\{))
    (LET
     ((<st_input> (<st_input> (LIST (REST (FIRST Stream)) (SECOND Stream)))))
     (IF (NOT (failure? <st_input>))
      (LIST (FIRST <st_input>) (CONS '{ (SECOND <st_input>))) NIL))
    NIL))
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\}))
    (LET
     ((<st_input> (<st_input> (LIST (REST (FIRST Stream)) (SECOND Stream)))))
     (IF (NOT (failure? <st_input>))
      (LIST (FIRST <st_input>) (CONS '} (SECOND <st_input>))) NIL))
    NIL))
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\;))
    (LET
     ((<st_input> (<st_input> (LIST (REST (FIRST Stream)) (SECOND Stream)))))
     (IF (NOT (failure? <st_input>))
      (LIST (FIRST <st_input>) (CONS (semi-colon) (SECOND <st_input>))) NIL))
    NIL))
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\,))
    (LET
     ((<st_input> (<st_input> (LIST (REST (FIRST Stream)) (SECOND Stream)))))
     (IF (NOT (failure? <st_input>))
      (LIST (FIRST <st_input>) (CONS (comma) (SECOND <st_input>))) NIL))
    NIL))
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\"))
    (LET ((<string> (<string> (LIST (REST (FIRST Stream)) (SECOND Stream)))))
     (IF (NOT (failure? <string>))
      (IF (AND (CONSP (FIRST <string>)) (EQL (FIRST (FIRST <string>)) #\"))
       (LET
        ((<st_input>
          (<st_input> (LIST (REST (FIRST <string>)) (SECOND <string>)))))
        (IF (NOT (failure? <st_input>))
         (LIST (FIRST <st_input>)
          (CONS (FORMAT NIL "~{~A~}" (SECOND <string>)) (SECOND <st_input>)))
         NIL))
       NIL)
      NIL))
    NIL))
  (BLOCK localfailure
   (LET ((<character> (<character> Stream)))
    (IF (NOT (failure? <character>))
     (LET ((<st_input> (<st_input> <character>)))
      (IF (NOT (failure? <st_input>))
       (LIST (FIRST <st_input>)
        (CONS (user-syntax-in (tokenise (SECOND <character>))) (SECOND <st_input>)))
       NIL))
     NIL)))
  (BLOCK localfailure
   (LET ((<comment> (<comment> Stream)))
    (IF (NOT (failure? <comment>))
     (LET ((<st_input> (<st_input> <comment>)))
      (IF (NOT (failure? <st_input>)) <st_input> NIL))
     NIL)))
  (BLOCK localfailure
   (LET ((<token> (<token> Stream)))
    (IF (NOT (failure? <token>))
     (LET ((<st_input> (<st_input> <token>)))
      (IF (NOT (failure? <st_input>))
       (LIST (FIRST <st_input>)
        (CONS (user-syntax-in (tokenise (SECOND <token>))) (SECOND <st_input>)))
       NIL))
     NIL)))
  (BLOCK localfailure
   (LET ((<whitespaces> (<whitespaces> Stream)))
    (IF (NOT (failure? <whitespaces>))
     (LET ((<st_input> (<st_input> <whitespaces>)))
      (IF (NOT (failure? <st_input>)) <st_input> NIL))
     NIL)))
  (BLOCK localfailure
   (LET ((<e> (<e> Stream)))
    (IF (NOT (failure? <e>)) (LIST (FIRST <e>) NIL) NIL)))))

(DEFUN comma () '|,|)

(DEFUN esc () #\Escape)


(EXPORT '(def decl type |@where| |@satisfied|))

;; Added by JUN
;; シグネチャ中の->を-->に置き換える 
(DEFUN <fix-signature> (XS)
  (IF (CONSP XS)
    (MAPCAR #'(LAMBDA (X)
                (COND ((CONSP X) (<fix-signature> X))
                      ((EQL X '->) '-->)
                      ;((EQL X '|,|) '*)
                      (T X)
                  ))
            XS)
    XS))

;; Added by JUN
(DEFUN <def/body/transform> (xs)
  (WHEN (MEMBER-IF (LAMBDA (x) (MEMBER x '(<- |@where| |@satisfied|)))
                   xs)
    (SETQ xs (COPY-LIST xs))
    ;; 1) 前処理
    ;; <-と@satisfies節の変換処理
    (DO ((H (MEMBER '<- xs) (MEMBER '<- (CDDR H))))
        ((NULL H))
      (COND ((EQL (THIRD H) '|@satisfied|)
              (SETF (SECOND H) `(fail-if (/. V (not (,(FOURTH H) V))) ,(SECOND H)))
              (SETF (CDDR H) (CDDDDR H)))
            (T
              (SETF (SECOND H) `(fail-if failed? ,(SECOND H))))))
    ;; 2) 後処理
    ;; @where節の処理
    (DO ((H (MEMBER '|@where| xs) (MEMBER '|@where| (CDDDDR H))))
        ((NULL H))
      ;; @where test-exp [<-|->] exp から [<-|->] exp where test-expに変換
      ;; 使用するセル数は変わらないので、置換で済ませる
      (LET ((test-exp (SECOND H))
            (arrow    (THIRD H))
            (main-exp (FOURTH H)))
        (SETF (FIRST H)   arrow
              (SECOND H)  main-exp
              (THIRD H)   'where
              (FOURTH H)  test-exp))))
  xs)
  
(DEFUN <def/transform> (V1)
  (COND ((AND (CONSP (CDR V1))
              (CONSP (SECOND V1)) (EQL '|:| (SECOND (SECOND V1))))
          (LET ((C (SECOND V1))
                (BODY (CDDR V1)))
            (IF (AND (= 3 (LENGTH C)) (EQL 'datatype (THIRD C)))
              ;; (datatype ...)に展開
              (proc_specialforms `(datatype ,(FIRST C) ,@BODY))
              ;; (define f {signature...} body...)に展開
              (proc_specialforms `(define ,(FIRST C) { ,@(CDDR C) } ,@(<def/body/transform> BODY))))))
        (T
          ;; (define ...)に展開
          (proc_specialforms `(define ,(SECOND V1) ,@(<def/body/transform> (CDDR V1)))))))

;; リストからcons表現への変換
;; (a (b c) d) --> (cons a (cons (cons b (cons c NIL)) (cons d NIL)))
(DEFUN <to-consing> (xs)
  (IF (ATOM xs)
    xs
    `(cons ,(<to-consing> (CAR xs)) ,(<to-consing> (CDR xs)))))
  
(DEFUN <decl/transform> (V1 &AUX tmp)
  (DOLIST (x (CDR V1) (LIST* '<xi/codes> (NREVERSE tmp)))
    (COND ((AND (CONSP x) (EQL 'type (FIRST x)) (EQL '|:| (THIRD x)) (>= (LENGTH x) 4))
            (LET* ((fixed (<fix-signature> (CDDDR x)))
                   (signature (IF (= 1 (LENGTH fixed)) (FIRST fixed) fixed)))
              (PUSH `(synonyms ,(SECOND x) ,signature)
                    tmp)))
          ((AND (CONSP x) (EQL '|:| (SECOND x)) (>= (LENGTH x) 3))
            (LET* ((fixed (<fix-signature> (CDDR x)))
                   (signature fixed))
              (PUSH `(declare ,(FIRST x) ,(<to-consing> signature))
                    tmp)))
          (T (ERROR "Xi: decl: illegal clause ~D" x)))))
          

(DEFUN proc_specialforms (V1)
  ;(PRINT (LIST V1))
  (COND

    ;; HACK JUN
    ((AND (CONSP V1)
          (NOT (EQL '|,| (CAR V1)))
          (MEMBER '|,| V1)
          (ODDP (LENGTH V1))
          (= (1+ (* 2 (COUNT '|,| V1)))
             (LENGTH V1)))
      ;;(PRINT V1)
      
      ;(proc_specialforms (LIST '|@p| (REMOVE '|,| V1)))
      (proc_specialforms (MAPCAR (LAMBDA (X) (IF (EQL '|,| X) '* X))
                                 V1))
      )

    ;; HACK JUN (, ...) --> (@p ...)
    ((AND (CONSP V1) (EQL '|,| (CAR V1)))
      (proc_specialforms (LIST* '@p (REMOVE '|,| (CDR V1)))))
      
    
    ;; HACK JUN
    ;; (/. -> exp) --> expへの変換
   ((AND (CONSP V1) (EQL '/. (CAR V1)) (EQL '-> (SECOND V1)) (= 3 (LENGTH V1)))
     (THIRD V1))
    
   ;; 多引数ラムダ式の展開
   ;; (/. A1 A2 .... An Exp) ==> (/. A1 (/. A2  ... (/. An Exp)))
   ((AND (CONSP V1) (EQ '/. (CAR V1)) (CONSP (CDR V1)) (CONSP (CDR (CDR V1)))
         (CONSP (CDR (CDR (CDR V1)))))
     (LET* ((V2 (CDR V1)))
       (LIST '/. (CAR V2) (proc_specialforms (CONS '/. (CDR V2))))))
   
   ;; 多束縛Letフォームの展開 
   ;; (let A1 e1 A2 e2 ... exp) ==> (let A1 e1 (let A2 e2 (let An en exp)))
   ((AND (CONSP V1) (EQ 'let (CAR V1)) (CONSP (CDR V1)) (CONSP (CDR (CDR V1)))
         (CONSP (CDR (CDR (CDR V1)))) (CONSP (CDR (CDR (CDR (CDR V1))))))
     (LET* ((V3 (CDR V1)) (V4 (CDR V3)))
       (LIST 'let (CAR V3) (CAR V4) (proc_specialforms (CONS 'let (CDR V4))))))
   
   ;; ３値以上のタプルの展開
   ;; (@p a b c) ==> (@p a (@p b c))
   ((AND (CONSP V1) (EQ '|@p| (CAR V1)) (CONSP (CDR V1)) (CONSP (CDR (CDR V1)))
         (CONSP (CDR (CDR (CDR V1)))))
     (LET* ((V5 (CDR V1)))
       (LIST '|@p| (CAR V5) (proc_specialforms (CONS '|@p| (CDR V5))))))
   
   ;; HACKED JUN (modified)
   ;; 多引数の右結合二項演算子の処理 associative? から associative-right? に変更
   ((AND (CONSP V1) (CONSP (CDR V1)) (CONSP (CDR (CDR V1)))
         (CONSP (CDR (CDR (CDR V1)))) (wrapper (associative-right? (CAR V1))))
     (LET* ((V6 (CAR V1)) (V7 (CDR V1)))
       (LIST V6 (CAR V7) (proc_specialforms (CONS V6 (CDR V7))))))
   
   ;; HACKED JUN (ADDED)
   ;; 多引数の左結合二項演算子の処理 applicative-left?が反応
   ((AND (CONSP V1) (CONSP (CDR V1)) (CONSP (CDR (CDR V1)))
         (CONSP (CDR (CDR (CDR V1)))) (wrapper (associative-left? (CAR V1))))
     (REDUCE (LAMBDA (a b) (LIST (CAR V1) a b))
             (CDR V1)))

   ;; JUN HACK new syntax `def'
   ;; (def (f : signature...) body...) --> (define f { signature...} body...)
   ;; (def (ident : datatype) body...) --> (datatype ident body...)
   ;; (def f body...) --> (define f body...)
   ((AND (CONSP V1) (EQ 'def (CAR V1)))
     (<def/transform> V1))

   ;; JUN HACK new syntax `decl'
   ;; (decl ...)
   ;; (decl (f:signature)) --> (declare f [...])
   ;; (decl (type a : b) --> (synonyms a b)
   ((AND (CONSP V1) (EQ 'decl (CAR V1)))
     (<decl/transform> V1))
                
   ;; define構文の展開
   ((AND (CONSP V1) (EQ 'define (CAR V1)) (CONSP (CDR V1))
         (CONSP (CDR (CDR V1))) (EQ '|{| (CAR (CDR (CDR V1))))
         (MEMBER '|}| (CDR (CDR (CDR V1)))))
     (LET* ((V8 (CDR V1)) (V9 (CDR V8)) (V10 (CDR V9)))
       (LET ((Signature (normalise-type (curry-type (collect-signature V10)))))
         (LET ((Rules (collect-rules V10)))
           ;; HACK JUN
           ;; 型シグネチャの変換 (内部の->を-->に変換)
           (SETQ Signature (<fix-signature> Signature))
           (CONS 'define
                 (CONS (CAR V8)
                       (CONS '|{| (THE LIST (APPEND Signature (LIST '|}|) Rules)))))))))
   
   
   ;; ユーザ定義のQi構文 define-qi-syntaxで定義されたものの適用
   ((AND (CONSP V1) (SYMBOLP (CAR V1)) (GET (CAR V1) '%qi-syntax%))
     (LET ((fn (GET (CAR V1) '%qi-syntax%)))
       (proc_specialforms (APPLY fn (CDR V1)))))
   
   ;; それ以外のフォーム（無展開）
   (T V1)))

(DEFUN semi-colon () '|;|)

(DEFUN user-syntax-in (X) (apply-user-syntax X *syntax-in*))

(DEFUN collect-rules (V557)
 (COND ((AND (CONSP V557) (EQ '} (CAR V557))) (CDR V557))
  ((CONSP V557) (collect-rules (CDR V557))) 
  (T (implementation_error 'collect-rules))))

(DEFUN collect-signature (V552)
 (COND ((AND (CONSP V552) (EQ '} (CAR V552))) NIL)
  ((CONSP V552) (CONS (CAR V552) (collect-signature (CDR V552))))
  (T (implementation_error 'collect-signature))))


(SETQ *syntax-in* NIL)

(DEFUN sugar (DIRECTION F N)
  (IF (NOT (SYMBOLP F)) (ERROR "~A must be a symbol~%" F))
  (COND ((EQ DIRECTION 'in) (SETQ *syntax-in* (set-user-syntax F N *syntax-in*)))
        ((EQ DIRECTION 'out) (SETQ *syntax-out* (set-user-syntax F N *syntax-out*)))
        (T (ERROR "direction must be in or out~%")))
  F)

(DEFUN sugar-list (DIRECTION)
  (COND ((EQ DIRECTION 'in) *syntax-in*)
        ((EQ DIRECTION 'out) *syntax-out*)
        (T (ERROR "direction must be in or out~%"))))
 
(DEFUN unsugar (F)
 (SETQ *syntax-in* (remove F *syntax-in*)) 
 (SETQ *syntax-out* (remove F *syntax-out*))
 F)   

(DEFUN apply-user-syntax (X Fs)
   (IF (NULL Fs)
       X
       (apply-user-syntax (FUNCALL (CAR Fs) X) (CDR Fs))))

(DEFUN syntax-in (F N)
  (SETQ *syntax-in* (set-user-syntax F N *syntax-in*)))

(DEFUN set-user-syntax (V5 V6 V7)
 (COND ((EQL -1 V6) (THE LIST (REMOVE V5 V7))) 
  ((EQL 1 V6) (CONS V5 V7))
  ((NULL V7) (LIST V5))
  ((CONSP V7) (CONS (CAR V7) (set-user-syntax V5 (1- V6) (CDR V7))))
  (T (implementation_error 'set-user-syntax))))
   
(DEFUN <character> (Stream)
 (OR
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\#))
    (IF
     (AND (CONSP (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream))))
      (EQL (FIRST (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream)))) #\\))
     (LET
      ((<token>
        (<token>
         (LIST (REST (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream))))
          (SECOND (LIST (REST (FIRST Stream)) (SECOND Stream)))))))
      (IF (NOT (failure? <token>))
       (LIST (FIRST <token>) (CONS #\# (CONS #\\ (SECOND <token>)))) NIL))
     NIL)
    NIL))
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\#))
    (IF
     (AND (CONSP (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream))))
      (EQL (FIRST (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream)))) #\\))
     (LET
      ((<it>
        (<it>
         (LIST (REST (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream))))
          (SECOND (LIST (REST (FIRST Stream)) (SECOND Stream)))))))
      (IF (NOT (failure? <it>))
       (LIST (FIRST <it>) (CONS #\# (CONS #\\ (SECOND <it>)))) NIL))
     NIL)
    NIL))))

(DEFUN <it> (Stream)
 (OR
  (BLOCK localfailure
   (IF (CONSP (FIRST Stream))
    (LIST (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream)))
     (CONS (CAAR Stream) NIL))
    NIL))))

(DEFUN <st_input1> (Stream)
 (OR
  (BLOCK localfailure
   (LET ((<st_input> (<st_input> Stream)))
    (IF (NOT (failure? <st_input>)) <st_input> NIL)))))

(DEFUN <st_input2> (Stream)
 (OR
  (BLOCK localfailure
   (LET ((<st_input> (<st_input> Stream)))
    (IF (NOT (failure? <st_input>)) <st_input> NIL)))))

(DEFUN <comment> (Stream)
 (OR
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\\))
    (LET ((<any> (<any> (LIST (REST (FIRST Stream)) (SECOND Stream)))))
     (IF (NOT (failure? <any>))
      (IF (AND (CONSP (FIRST <any>)) (EQL (FIRST (FIRST <any>)) #\\))
       (LIST (FIRST (LIST (REST (FIRST <any>)) (SECOND <any>))) NIL) NIL)
      NIL))
    NIL))))

(DEFUN <any> (Stream)
 (OR
  (BLOCK localfailure
   (IF
    (AND (CONSP (FIRST Stream))
     (wrapper (not-slash? (FIRST (FIRST Stream)))))
    (LET ((<any> (<any> (LIST (REST (FIRST Stream)) (SECOND Stream)))))
     (IF (NOT (failure? <any>)) (LIST (FIRST <any>) NIL) NIL))
    NIL))
  (BLOCK localfailure
   (LET ((<e> (<e> Stream)))
    (IF (NOT (failure? <e>)) (LIST (FIRST <e>) NIL) NIL)))))

(DEFUN not-slash? (V10) (COND ((EQL #\\ V10) 'false) (T 'true)))

(DEFUN <string> (Stream)
 (OR
  (BLOCK localfailure
   (IF
    (AND (CONSP (FIRST Stream))
     (wrapper (not-double-quote? (FIRST (FIRST Stream)))))
    (LET ((<string> (<string> (LIST (REST (FIRST Stream)) (SECOND Stream)))))
     (IF (NOT (failure? <string>))
      (LIST (FIRST <string>) (CONS (CAAR Stream) (SECOND <string>))) NIL))
    NIL))
  (BLOCK localfailure
   (LET ((<e> (<e> Stream)))
    (IF (NOT (failure? <e>)) (LIST (FIRST <e>) NIL) NIL)))))

(DEFUN not-double-quote? (V15) (COND ((EQL #\" V15) 'false) (T 'true)))

(DEFUN <token> (Stream)
 (OR
  (BLOCK localfailure
   (LET ((<alphanum> (<alphanum> Stream)))
    (IF (NOT (failure? <alphanum>))
     (LET ((<token> (<token> <alphanum>)))
      (IF (NOT (failure? <token>))
       (LIST (FIRST <token>) (CONS (SECOND <alphanum>) (SECOND <token>))) NIL))
     NIL)))
  (BLOCK localfailure
   (LET ((<alphanum> (<alphanum> Stream)))
    (IF (NOT (failure? <alphanum>))
     (LIST (FIRST <alphanum>) (CONS (SECOND <alphanum>) NIL)) NIL)))))

(DEFUN tokenise (V121)
 (COND ((AND (CONSP V121) (EQL #\> (CAR V121)) (NULL (CDR V121))) 'qi_>)
  ((AND (CONSP V121) (EQL #\> (CAR V121)) (NULL (CDR V121))) 'qi_>)
  ((AND (CONSP V121) (EQL #\< (CAR V121)) (NULL (CDR V121))) 'qi_<)
  ((AND (CONSP V121) (EQL #\= (CAR V121)) (NULL (CDR V121))) 'qi_=)
  ((AND (CONSP V121) (EQL #\: (CAR V121)) (NULL (CDR V121))) (colon))
  ((AND (CONSP V121) (EQL #\> (CAR V121)) (CONSP (CDR V121))
    (EQL #\= (CAR (CDR V121))) (NULL (CDR (CDR V121))))
   'qi_>=)
  ((AND (CONSP V121) (EQL #\< (CAR V121)) (CONSP (CDR V121))
    (EQL #\= (CAR (CDR V121))) (NULL (CDR (CDR V121))))
    'qi_<=)
  ;; Added by JUN
  ((AND (CONSP V121) (EQL #\/ (CAR V121)) (CONSP (CDR V121))
    (EQL #\= (CAR (CDR V121))) (NULL (CDR (CDR V121))))
   'qi_/=)
  (T (READ-FROM-STRING (FORMAT NIL "~{~C~}" V121)))))

(DEFUN colon () '|:|)

(DEFUN <alphanum> (Stream)
 (OR
  (BLOCK localfailure
   (IF
    (AND (CONSP (FIRST Stream)) (wrapper (alpha? (FIRST (FIRST Stream)))))
    (LIST (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream))) (CAAR Stream))
    NIL))))

(DEFUN alpha? (V17)
 (IF
  (MEMBER V17
   '(#\; #\, #\\ #\[ #\] #\( #\) #\} #\{ #\" #\Space #\Return #\Newline #\Tab #\|)
   :TEST 'CHAR-EQUAL)
  'false 'true))

(DEFUN <whitespaces> (Stream)
 (OR
  (BLOCK localfailure
   (LET ((<whitespace> (<whitespace> Stream)))
    (IF (NOT (failure? <whitespace>))
     (LET ((<whitespaces> (<whitespaces> <whitespace>)))
      (IF (NOT (failure? <whitespaces>)) (LIST (FIRST <whitespaces>) NIL) NIL))
     NIL)))
  (BLOCK localfailure
   (LET ((<whitespace> (<whitespace> Stream)))
    (IF (NOT (failure? <whitespace>)) (LIST (FIRST <whitespace>) NIL) NIL)))))

(DEFUN <whitespace> (Stream)
 (OR
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\Space))
    (LIST (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream)))
     (CONS #\Space NIL))
    NIL))
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\Return))
    (LIST (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream)))
     (CONS #\Return NIL))
    NIL))
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\Newline))
    (LIST (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream)))
     (CONS #\Newline NIL))
    NIL))
  (BLOCK localfailure
   (IF (AND (CONSP (FIRST Stream)) (EQL (FIRST (FIRST Stream)) #\Tab))
    (LIST (FIRST (LIST (REST (FIRST Stream)) (SECOND Stream)))
     (CONS #\Tab NIL))
    NIL))))

(DEFUN cons_form (V18)
 (COND ((NULL V18) NIL) 
  ((AND (CONSP V18) (CONSP (CDR V18)) (EQ 'bar# (CAR (CDR V18)))
    (CONSP (CDR (CDR V18))) (NULL (CDR (CDR (CDR V18)))))
   (CONS 'cons (CONS (CAR V18) (CDR (CDR V18)))))
  ((CONSP V18) (LIST 'cons (CAR V18) (cons_form (CDR V18))))
  (T V18)))
