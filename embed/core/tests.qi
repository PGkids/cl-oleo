(speed 0)

(define diagnostics
 -> (qi::harness
(maxinferences 100000000)
(cd "")
(if true 4 (i)) 
(and false (i)) 
(or true 7) 
(cd "../Qi Programs") 
(load "Chap2/fruit machine.qi") 
(fruit-machine start) 
(load "Chap3/prime.qi") 
(prime? 1000003) 
(load "Chap3/mutual.qi") 
(even? 56) 
(odd? 77) 
(load "Chap3/change.qi") 
(count-change 100) 
(load "Chap3/goldbach version 1.qi") 
(load "Chap4/cartprod.qi") 
(cartesian-product [1 2 3] [a b c]) 
(load "Chap4/powerset version 1.qi") 
(powerset [1 2 3 4]) 
(load "Chap4/powerset version 2.qi") 
(powerset [1 2 3 4]) 
(load "Chap4/goldbach version 2.qi") 
(load "Chap5/bubble version 1.qi") 
(bubble-sort [1 2 3 4 5 6 7 8 9]) 
(load "Chap5/bubble version 2.qi") 
(bubble-sort [1 2 3 4 5 6 7 8 9]) 
(load "Chap5/newton version 1.qi") 
(newtons-method 4.5) 
(load "Chap5/newton version 2.qi") 
(newtons-method 4.5) 
(load "Chap5/spreadsheet.qi") 
(assess-spreadsheet
  [[jim [wages (/. Spreadsheet (get frank wages Spreadsheet))]
        [tax (/. Spreadsheet (* (get frank tax Spreadsheet) .8))]]
   [frank [wages 20000]
          [tax (/. Spreadsheet (* .25 (get frank wages Spreadsheet)))]]]) 
(load "Chap6/semantic net.qi") 
(assert [Mark_Tarver is_a man]) 
(assert [man type_of human]) 
(query [is Mark_Tarver human]) 
(load "Chap7/proplog version 1.qi") 
(backchain q [[q <= p] [q <= r] [r <=]]) 
(backchain q [[q <= p] [q <= r]]) 
(load "Chap7/proplog version 2.qi") 
(backchain q [[q <= p] [q <= r] r]) 
(backchain q [[q <= p] [q <= r]]) 
(load "Chap8/parser.qi") 
(parse ["the" "boy" "likes" "the" "girl"]) 
(parse ["the" "cat" "likes" "the" "girl"]) 
(eval [* 3 4]) 
(eval [define f
        [cons X [cons Y Z]] -> Z]) 
(f [1 2 3]) 
(load "Chap8/metaprog.qi") 
(generate_parser [sent --> np vp  np --> name  np  --> det n 
                  name --> "John"  name --> "Bill"  
                  name --> "Tom" det  --> "the"  det  --> "a"
                  det  --> "that" det  --> "this"  
                  n --> "girl"  n --> "ball" 
                  vp --> vtrans np  vp --> vintrans  
                  vtrans --> "kicks" vtrans --> "likes"
                  vintrans --> "jumps" vintrans --> "flies"]) 
(parse sent ["the" "girl" "likes" "the" "ball"]) 
(parse sent ["the" "girl" "likes" "the" "cat"]) 
(tc +)
(load "Chap10/proplog version 3.qi") 
(backchain q [[q <= p] [q <= r] [r <=]]) 
(backchain q [[q <= p] [q <= r]]) 
(load "Chap10/N queens.txt")
\(n-queens 8)\
(load "Chap11/calculator.qi")
(do-calculation [[num 12] + [[num 7] * [num 45]]]) 
(load "Chap11/binary.qi")
(complement [1 0 1 0 0 1])
(load "Chap11/streams.qi")
(delay (@p 0 (+ 1) (/. X false)))
(force (@p 0 (+ 1) (/. X false)))
(end? (@p 0 (+ 1) (/. X false)))
(load "Chap11/whist.qi")
(tc -)
(load "Chap12/structures(untyped).qi")
(defstruct ship [length name])
(make-ship 200 "Mary Rose")
(ship-length (make-ship 200 "Mary Rose"))
(ship-name (make-ship 200 "Mary Rose"))
(load "Chap12/structures(typed).qi")
(tc +)
(defstruct ship [(@p length number) (@p name string)])
(make-ship 200 "Mary Rose")
(ship-length (make-ship 200 "Mary Rose"))
(ship-name (make-ship 200 "Mary Rose"))
(tc -)
(load "Chap12/classes(untyped).qi")
(defclass ship [length name])
(set s (make-instance ship))
(has-value? length (value s))
(set s (change-value (value s) length 100))
(get-value length (value s) )
(load "Chap12/classes(typed).qi")
(tc +)
(defclass ship [(@p length number) (@p name string)])
(has-value? length (make-instance ship))
(change-value (make-instance ship) length 100)
(get-value length (change-value (make-instance ship) length 100))
(tc -)
(load "Chap12/stack.qi")
(tc +)
(empty-stack _)
(push 0 (empty-stack _))
(pop (push 0 (empty-stack _)))
(preclude-all-but [])
(load "Chap13/interpreter.qi")
(normal_form
  [[[y-combinator 
     [/. ADD [/. X [/. Y [if [= X 0] Y 
           [[ADD [-- X]] [++ Y]]]]]]]  2] 3])
(normal_form
[[[/. [@p X Y] X] 
[y-combinator  [/. T 
[@p [/. A [cases [[/. 1 false] A]
                 [[/. X [[[/. [@p X Y] Y] T] [-- X]]] A]]]
    [/. A [cases [[/. 1 true] A]
                 [[/. X [[[/. [@p X Y] X] T] [-- X]]] A]]]]]]] 6])
(preclude-all-but [])
(load "Chap15/pc.qi")
(load "Chap15/proof assistant.qi")
(pc_decision_procedure [(@p [] [p <=> p])])
(load "Chap15/autofol.qi")
(load "Chap15/fol prbs.qi")
(preclude-all-but [])
(load "Chap16/mymycin.qi")
(preclude-all-but [])
(load "Chap16/wardrop.qi")
(model 7 7 7) 
(preclude-all-but [])
(m-prolog 
   "likes(willi, X) :- likes(mark, X).
    likes(mark, chocolate).
    likes(mark, tea).") 
(prolog? (likes mark X) (return X)) 
(m-prolog "fads(X) :- findall(Y,[likes,X,Y],Friends), return(Friends).")
(prolog? (fads mark)) 
(m-prolog 
"prop(A,C) :- pr([[~, C] | A]).

pr(A) :- mem([~ P], A), mem(P, A), !.
pr(A) :- consistent(A), !, when(false).
pr((mode [[P,&,Q] | A] -)) :- !, pr([P,Q | A]).
pr((mode [[P,<=>,Q] | A] -)) :- !, pr([[P,=>,Q],[Q,=>,P] | A]).
pr((mode [[P,=>,Q] | A] -)) :- !, pr([[[~ P],v,Q] | A]).
pr((mode [[~ [P,v,Q]] | A] -)) :- !, pr([[~,P],[~,Q] | A]).
pr((mode [[~ [P,&,Q]] | A] -)) :- !, pr([[[~,P],v,[~,Q]] | A]).
pr((mode [[~ [P,=>,Q]] | A] -)) :- !, pr([P,[~,Q] | A]).
pr((mode [[~ [P,<=>,Q]] | A] -)) :- !, pr([[~,[[P,=>,Q],v,[~,[Q,=>,P]]]] | A]).
pr((mode [[P,&,Q] | A] -)) :- !, pr([P,Q | A]).
pr((mode [[P,v,Q] | A] -)) :- !, pr([P | A]), !, pr([Q | A]).
pr((mode [P | Ps] -)) :- app(Ps, [P], Qs), !, pr(Qs).
 
consistent([]).
consistent([P | Ps]) :- when((symbol? P)), !, consistent(Ps).
consistent([[~ P] | Ps]) :- when((symbol? P)), !, consistent(Ps).
 
app([], X, X).
app((mode [X | Y] -) W [X | Z]) :- app(Y, W, Z).
 
mem(X, (mode [X | _] -)).
mem(X, (mode [_ | Y] -)) :- mem(X, Y).") 

(prolog? (prop []  [[[p <=> q] <=> r] <=> [p <=> [q <=> r]]])) 

(m-prolog 

"mapit(_, [], []).
 mapit(Pred,[X | Y],[W | Z]) :- call([Pred, X, W]), mapit(Pred, Y, Z).

 consit(X,[1 X]).") 

(prolog? (mapit consit [1 2 3] Out) (return Out)) 

(m-prolog
"different(X,Y) :- ~([identical X Y]).
 
 ~(P) :- call(P), !, fail.
 ~(_).

 fail :- when(false).") 

 (prolog? (different a b)) 

 (prolog? (different a a)) 

(m-prolog 

"likes(john, X) :- tall(X), pretty(X).
 tall(mary).
 pretty(mary).") 

(prolog? (likes john Who) (return Who)) 

(defcc <sent>
<np> <vp>;) 

(defcc <det>
the; a;) 

(defcc <np>
<det> <n>;
<name1>;) 

(defcc <n>
cat; dog;)  

(defcc <name1>
Bill; Ben;) 

(defcc <vp>
<vtrans> <np>;) 

(defcc <vtrans>
likes; chases;) 

(compile <sent> [the cat likes the dog]) 

(compile <sent> [the cat likes the canary]) 

(compile <vp> [chases the cat]) 

(defcc <bcs>
[<bs>] [<cs>];) 

(defcc <bs>
b <bs>; 
b;) 

(defcc <cs>
c <cs>; 
c;) 

(compile <bcs> [[b b b] [c c]]) 

(defcc <sent>
<np> <vp> := (question <np> <vp>);) 

(define question
NP VP -> (append [Is it true that your father] VP [?])) 

(compile <sent> [the cat likes the dog])  

(defcc <as>
a <as> := [b | <as>];
a := [b];) 

(compile <as> [a a a]) 

(defcc <find-digit>
<digit> <morestuff> := <digit>;
<digit> := <digit>;
-*- <find-digit> := <find-digit>;) 

(defcc <morestuff>
-*- <morestuff>; 
-*-;) 

(defcc <digit>
0; 1; 2; 3; 4; 5; 6; 7; 8; 9;) 

(compile <find-digit> [a v f g 6 y u]) 

(defcc <find-digit>
<digit> <morestuff> := -s-;
<digit> := -s-;
-*- <find-digit> := <find-digit>;) 

(compile <find-digit> [a v f g 6 y u]) 

(defcc <asbscs>
<as> <bs> <cs>;) 

(defcc <as>
a <as>; 
a ;) 

(defcc <bs>
b <bs>; 
b; 
<e>;) 

(defcc <cs>
c <cs>; 
c;) 

(compile <asbscs> [a a a b b c]) 

(defcc <bs>
b <bs>; 
b; 
<e> := [ ];) 

(compile <asbscs> [a a a b b c]) 

(defcc <find-digit>
<digit> <morestuff> := <digit>;
<digit> := <digit>;
-*- <find-digit> := <find-digit>;) 

(defcc <digit>
-*- := (one_of -*- [0 1 2 3 4 5 6 7 8 9]);) 

(define one_of
X Y -> (if (element? X Y) X #\Escape)) 

(compile <find-digit> [a v f g 6 y u]) 

(defcc <anbncn>
<as> <bs> <cs> := (if (equal-length? [<as> <bs> <cs>]) 
                      (appendall [<as> <bs> <cs>]) 
                      #\Escape);) 

(defcc <as>
a <as>; 
a;) 

(defcc <bs>
b <bs>; 
b;) 

(defcc <cs>
c <cs>; 
c;) 

(define equal-length?
[] -> true
[L] -> true
[L1 L2 | Ls] -> (and (= (length L1) (length L2)) (equal-length? [L2 | Ls])))

(define appendall
[] -> []
[L | Ls] -> (append L (appendall Ls))) 

(compile <anbncn> [a a a b b b c c c]) 

(compile <anbncn> [a a a b b b c c]) 

(cd "")
(tc -)))

(FORMAT T "The following system functions have not been defined: ~{~A, ~}"
          (MAPCAN (/. F (IF (FBOUNDP F) [] [F])) (difference (value qi::*sysfuncs*)
                                                              [multi rule /.])))

(FORMAT T "The following system functions have not been given arities: ~{~A, ~}"
          (MAPCAN (/. F (IF (EQ (qi::arity F) -1) [F] [])) (value qi::*sysfuncs*)))

(FORMAT T "The following system functions have not been given types: ~{~A, ~}"
          (MAPCAN (/. F (IF (NULL (qi::signature F)) [F] [])) (value qi::*sysfuncs*)))


(diagnostics)
(speed 1)
(diagnostics)
(speed 2)
(diagnostics)
(speed 3)
(diagnostics)