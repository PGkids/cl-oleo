;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; 作業用空間 Q
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(defpackage :Q 
;  (:use :cl :cluw :xi.core))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(use-package :clap.xi.core :clap.qspace)


(let* ((*readtable* clap.xi.core:*qi-readtable*))
  (set-dispatch-macro-character 
   #\# #\{ 
   #'cluw:|#{-READER|))

(DEFUN CLAP.XI.CORE:QILOAD (filename)
  (let ((*package* (find-package :Q))
        (*readtable* clap.xi.core:*qi-readtable*))
    (clap.xi.core:|load| filename)))


(in-package :clap.xi.core)

(defvar *<loading-results>*)
  
(defun <execute-code> (c)
  (let* ((typing (when (consp c)
                  (case (first c)
                    (|define| (eql '|{| (third c)))
                    (|datatype| t)
                    (|declare| nil)
                    (|synonyms| t))))
    
         (result (|load-help| (if typing '|true| '|false|)
                              (list c))))
    (push result *<loading-results>*)))

(defun <execute-each-codes> (x)
  (cond ((and (consp x)
              (eql '|<xi/codes>| (car x)))
          (mapc #'<execute-each-codes> (cdr x)))
        (t
          (<execute-code> x))))
        

(defun %load% (V1)
  (setq |*tempsigs*| nil)
  (|initialise_environment|)
  (LET (*V-STACK*
        (|*inferences*| 0)
        (*<loading-results>* nil))
    (mapc #'<execute-each-codes> V1)
    (nreverse *<loading-results>*)))
    ;(|load-help| |*tc*| (THE LIST V1)))
  ;;(IF (EQ |*tc*| '|true|) 
  ;;  (|output| "~%~%typechecked in ~A inferences" (THE NUMBER (|inferences| '_))))
  ;;(TERPRI)
  ;;|loaded|
  ;)

(defun <special-symbol-p> (s)
  (member s '(|@failure|)))


;; core-03-reader_load_3.lispから呼ばれる
(defun %local-intern-needed-p% (name)
  (let ((c (char name 0)))
    (or (upper-case-p c)
        (member c '(#\~ #\< #\* #\+ #\%))      
        (and (eq c #\_)
             (not (string= name "_"))))))

;; core-03-reader_load_3.lispから呼ばれる
(defun %local-intern% (name pkg)
  (let ((*package* pkg)
        (c (char name 0)))
    (intern (if (eq c #\~)
              (string-upcase (subseq name 1))
              name))))

(defun %trans% (x)
  (cond ((symbolp x)   
          (if (<special-symbol-p> x)
            (case x
              (|@failure| (list '|<<xi-simple-fail>>| '|true|)))
            x))
        ((atom x) x)
        (t (do ((cur x (cdr cur))
                tmp)
               ((atom cur)
                (let ((result (nreverse tmp)))
                  (setf (cdr (last result)) (%trans% cur))
                  result)
                )
             (push (%trans% (car cur)) tmp)))))

(defun %need-trans-p% (x)
  (cond ((symbolp x) (<special-symbol-p> x))
        ((atom x) nil)
        (t (do ((cur x (cdr cur)))
               ((atom cur)
                (%need-trans-p% cur))                
             (when (%need-trans-p% (car cur))
               (return t))))))


;(SETF (READTABLE-CASE *READTABLE*) :UPCASE)

;(xi.core::save)
;#-(OR ALLEGRO LISPWORKS) (quit)


(defmacro declare-for-qi (lisp-name qi-signature)
  (let* ((qi-name (if (get lisp-name '<qi-name>)
                    (get lisp-name '<qi-name>)
                    (setf (get lisp-name '<qi-name>)
                            (gensym (string-concat "qi;" (symbol-name lisp-name))))))
         (arity (count '~--> qi-signature))
         (tmp-vars (do ((tmp nil (push (gensym) tmp))
                        (n arity (1- n)))
                       ((zerop n)
                        tmp))))

    `(progn
      (defun ,qi-name ,tmp-vars (,lisp-name ,@tmp-vars))
      (define-compiler-macro ,qi-name ,tmp-vars (list ',lisp-name ,@tmp-vars))
      (~declare ',qi-name ',qi-signature)
      ',lisp-name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(defun <register-readers> ()
  ;; Qiパッケージへのシンボルのインターン
  ;; ~fooBar は USER::|fooBar|のショートカットとなる
  ;; * < % で始まる長さ１以上シンボル、及び、_で始まる長さ２以上のシンボルは
  ;; ローカルなパッケージ（呼び出し元パッケージ）にインターンされる
  (set-macro-character
   #\~
   (lambda (stream char1)
     (declare (ignore char1))

     (let (result
           (cur-pkg *package*))
       (let* ((*package* (cluw:memoized (find-package :Q)))
              (*readtable* CLAP.XI.CORE:*QI-READTABLE*)
              (src (read stream t nil t)))
         (setf result (if (CLAP.XI.CORE::%need-trans-p% src)
                        (let ((*package* cur-pkg))
                          (CLAP.XI.CORE::%trans% src))
                        src)))
       result)))


  )

;(SETF (READTABLE-CASE *READTABLE*) :UPCASE)

;; (\リーダの定義

(defun qi-reader (stream &key transformer pre-execute)
  (do (c 
       tmp
       (paren-count (list 0))
       escape-flag
       lambda-flag
       reserve-op-mode
       bar-flag
       end-flag)
      (end-flag
       (let* ((raw-chars (nreverse tmp))
              (chars (if transformer
                       (funcall transformer raw-chars)
                       raw-chars))
              (raw-parsed (let ((*<caller-package>* *package*)
                                (*package* (find-package :Q))
                                (*readtable* clap.xi.core:*qi-readtable*)
                                (errstr "Xi.Core: parse failure: ~%~%~{~C~} ..."))
                            (CLAP.XI.CORE:|compile| 'CLAP.XI.CORE::|<st_input>| chars errstr)))
                                        ;`(progn ,@(mapcar (lambda (x) `(XI.CORE::|eval| ',x))
                                        ;                  parsed))))
              (parsed (if (CLAP.XI.CORE::%need-trans-p% raw-parsed)
                        (CLAP.XI.CORE::%trans% raw-parsed)
                        raw-parsed))
              (form (if pre-execute
                      (let ((|*<definition-only-p>*| t))
                        (CLAP.XI.CORE::%load% parsed)
                        |*<definition-only-p>*|)
                      `(CLAP.XI.CORE::%load% ',parsed))))
         ;(WARN "~D" form)
         form
         ;; (if type-check
         ;;   `(let ((xi.core::|*tc*| ',type-check)) ,form)
         ;;   form)
         ))
    
    (unless (characterp (setq c (read-char stream)))
      (error "Xi.Core: unexpected end of stream"))
    

    (when reserve-op-mode
      (unless (member c '(#\- #\= #\< #\>))
        (cond (NIL (equal '(#\-) reserve-op-mode)
                ;; 一文字の-記号は、数値の符号またはシンボルの一部と見做す
                (push #\- tmp) )
              ((let ((n (length reserve-op-mode)))
                 (and (> n 2)
                      (member (first reserve-op-mode) '(#\- #\=))
                      (= n (count (first reserve-op-mode) reserve-op-mode))))
                ;; ３文字以上連続する{=,-}は３文字。-は_に内部変換することに注意。
                (setq tmp (nconc (if (eql #\- (first reserve-op-mode))
                                   (list #\Space #\_ #\_ #\_ #\Space)
                                   (list #\Space #\= #\= #\= #\Space))
                                 tmp)))
                      
              (t
                ;;(setq tmp (nconc (list #\Space) reserve-op-mode (list #\Space) tmp)))
                (setq tmp (nconc reserve-op-mode tmp)))
              )
        (setq reserve-op-mode nil)
        ))
                      
    
    (cond (lambda-flag
            (setq lambda-flag nil)
            ;;(push c tmp)
            (push #\/ tmp)
            (push #\. tmp)
            (push #\Space tmp)
            (push c tmp)
            )
          (escape-flag
            (setq escape-flag nil)
            (push c tmp))
          (bar-flag
            (when (eql c #\|)
              (setq bar-flag nil)
                                        ;(push c tmp)
              )

            ;(setq bar-flag nil)
            ;(unless (eq c #\|)
                                        ;  (error "#Q .. }#: misplaced |")))
            )

          (reserve-op-mode
            (push c reserve-op-mode)
            (cond ((or (equal '(#\> #\-) reserve-op-mode) ;; ->
                       ;;(equal '(#\> #\- #\-) reserve-op-mode) ;; -->
                       ;;(equal '(#\> #\>) reserve-op-mode) ;; >>
                       (equal '(#\> #\=) reserve-op-mode) ;; =>
                       (equal '(#\- #\<) reserve-op-mode)) ;; <-
                    (setq tmp (nconc (list #\Space) reserve-op-mode (list #\Space) tmp))
                    (setq reserve-op-mode nil))
                  ;; ((equal '(#\> #\= #\=) reserve-op-mode) ; ==> to ___
                  ;;   (setq tmp (nconc (list #\Space #\_ #\_ #\_ #\Space) tmp))
                  ;;   (setq reserve-op-mode nil))
                  ;; ((equal '(#\> #\= #\<) reserve-op-mode) ; <=> to ===
                  ;;   (setq tmp (nconc (list #\Space #\= #\= #\= #\Space) tmp))
                  ;;   (setq reserve-op-mode nil))

                  )

            )
          ((eq c #\\) 
            (cond ((eq (car tmp) #\#) ;;文字リテラル#\における\を読み込んだ場合
                    (setq escape-flag t)
                    (push #\\ tmp))
                  ((eq (car tmp) #\()
                    (setq lambda-flag t))))

          ((member c '(#\- #\= #\< #\>))
            ;(push #\Space tmp)
            ;(push c tmp)
            (setq reserve-op-mode (list c))
            )

          ((and (eq c #\#) (consp tmp) (eql #\( (car tmp)))
            (setq tmp (nconc (list #\Space #\;) tmp)))
          ((and (eq c #\.) (consp tmp)
                ;; 小数点表記 ddd.ddd と /. の場合を除く
                (not (digit-char-p (car tmp)))
                (not (eq #\/ (car tmp))))
            (setq tmp (nconc (list #\Space #\; #\Space) tmp))) ;HACK
          ((and (eq c #\`)) (push (vector '|<lisp>| (read stream t nil t))
                                  tmp)); HACK
          ((eq c #\') (setq tmp (nconc (list #\Space #\| #\| #\Space) tmp))) ;HACK
          ((eq c #\:) (setq tmp (nconc (list #\Space #\| #\Space) tmp)))

          ;;;;;;;;;;;; OBSOLETE ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
          ;; ((eq c #\：) (setq tmp (nconc (list #\Space #\: #\Space) tmp))) ;OBSOLETE
          ;; ((eq c #\⇒) (setq tmp (nconc (coerce " ___ " 'list) tmp)))
          ;; ((eq c #\⇔) (setq tmp (nconc (coerce " === " 'list) tmp)))
          ;; ((eq c #\＝) (setq tmp (nconc (coerce " >- " 'list) tmp)))
          ;; ((eq c #\≒) (setq tmp (nconc (coerce " -< " 'list) tmp)))
          ;; ((eq c #\→) (setq tmp (nconc (coerce " >-- " 'list) tmp)))
          ;; ((eq c #\；) (push #\; tmp))
          ;; ((eq c #\｜) (push #\| tmp))
          ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

          
          ((eq c #\") 
            (unread-char #\" stream)
            (push (vector '|<string>| (read stream t nil t)) tmp))
          (nil (eq c #\") 
               (unread-char #\" stream)
               
            (let ((src-str (format nil "~S" (read stream t nil t))))
              (setq tmp (nconc (nreverse (coerce src-str 'list))
                               tmp))))
          ((eq c #\;) (do () ((eq #\Newline
                                  (read-char stream)))))
          ((eq c #\|)
            (setq bar-flag t))
          
          ((and (eq c #\{) (eql #\# (car tmp)))
            ;; #{ の処理: #\(に置換し、対応する#\)の数をセット
            (setf (car tmp) #\()
            (incf (car paren-count)))
          
          (t 
            (push c tmp)
            (cond ((eq c #\() (push 0 paren-count))
                  ((eq c #\))
                    (let ((m (pop paren-count)))
                      ;; #{ の後処理。対応する#\)を必要な数だけ追加する
                      (unless (zerop m)
                        (dotimes (_ m) (push #\) tmp))))
                    (when (null paren-count)
                      (pop tmp)
                      (setq end-flag t))))))))



(defun <trans> (header chars footer)
  (nconc (coerce header 'list)
         chars
         (coerce footer 'list)))


(cluw:define-lpar-backslash-reader "XI" (stream)
  (FORMAT T "\\XI is OBSOLETE~%")
  (qi-reader stream))

(cluw:define-lpar-backslash-reader "XDEF" (stream)
  (FORMAT T "\\XDEF is OBSOLETE~%")
  (qi-reader stream :pre-execute t :transformer (lambda (chars) (<trans> "(def " chars ")"))))

(cluw:define-lpar-backslash-reader "XLAMBDA" (stream)
  (FORMAT T "\\XLAMBDA is OBSOLETE~%")
  (qi-reader stream :pre-execute t :transformer (lambda (chars) (<trans> "(def xi_lambda " chars ")"))))

(cluw:define-lpar-backslash-reader "XDEFUN" (stream)
  (FORMAT T "\\XDEFUN is OBSOLETE~%")
  (let ((*<LOCALLY-P>* T))
    (qi-reader stream :pre-execute t :transformer (lambda (chars) (<trans> "(def " chars ")")))))

(cluw:define-lpar-backslash-reader "XDEFMACRO" (stream)
  (FORMAT T "\\XDEFMACRO is OBSOLETE~%")
  (let ((*<LOCALLY-P>* T)
        (*<DEF-OP>* 'DEFMACRO))
    (qi-reader stream :pre-execute t :transformer (lambda (chars) (<trans> "(def " chars ")")))))

(cluw:define-lpar-backslash-reader "X" (stream)
  (FORMAT T "\\X is OBSOLETE~%")
  (let ((*<LOCALLY-P>* T)
        (*<DEF-OP>* NIL))
    (qi-reader stream :pre-execute t :transformer (lambda (chars) (<trans> "(def " chars ")")))))

;;;

(cluw:define-lpar-backslash-reader "XENV" (stream)
  (qi-reader stream))

(cluw:define-lpar-backslash-reader "DEF" (stream)
  (qi-reader stream :pre-execute t :transformer (lambda (chars) (<trans> "(def " chars ")"))))

(cluw:define-lpar-backslash-reader "LAMBDA" (stream)
  (qi-reader stream :pre-execute t :transformer (lambda (chars) (<trans> "(def xi_lambda " chars ")"))))

(cluw:define-lpar-backslash-reader "DEFUN" (stream)
  (let ((*<LOCALLY-P>* T))
    (qi-reader stream :pre-execute t :transformer (lambda (chars) (<trans> "(def " chars ")")))))

(cluw:define-lpar-backslash-reader "DEFMACRO" (stream)
  (let ((*<LOCALLY-P>* T)
        (*<DEF-OP>* 'DEFMACRO))
    (qi-reader stream :pre-execute t :transformer (lambda (chars) (<trans> "(def " chars ")")))))

(cluw:define-lpar-backslash-reader "LET" (stream)
  (let ((*<LOCALLY-P>* T)
        (*<DEF-OP>* NIL))
    (qi-reader stream :pre-execute t :transformer (lambda (chars) (<trans> "(def " chars ")")))))


;;OBSOLETE
;;(cluw:define-lpar-backslash-reader "XDECL" (stream)
;;  (qi-reader stream :transformer (lambda (chars) (<trans> "(decl " chars ")"))))

;;OBSOLETE
;;(cluw:define-lpar-backslash-reader "X-YACC" (stream)
;;  (qi-reader stream))


(cluw:define-lpar-backslash-reader "X-PROLOG" (stream)
  (do (c 
       tmp
       escape-flag
       comma-flag
       bar-flag
       end-flag)
      (end-flag
       (let* ((chars (nreverse (cdr tmp)))
              (parsed (let ((*package* (find-package :Q))
                            (*readtable* clap.xi.core:*qi-readtable*)
                            (errstr "syntax error in Prolog(Qi) here: ~%~%~{~C~}"))
                        (CLAP.XI.CORE:|compile| 'CLAP.XI.CORE::|<horn_clauses>| chars errstr))))
         (if (CLAP.XI.CORE::%need-trans-p% parsed)
           `(CLAP.XI.CORE:|s-prolog| ',(CLAP.XI.CORE::%trans% parsed))
           `(CLAP.XI.CORE:|s-prolog| ',parsed))))    
    
    (unless (characterp (setq c (read-char stream)))
      (error "Xi.Core: unexpected end of stream"))

    (when comma-flag
      (unless (eq c #\))
        (setq comma-flag nil)))

    (cond (comma-flag
            (setq end-flag t))
          (escape-flag
            (setq escape-flag nil)
            (push c tmp))
          (bar-flag ;; TODO
            (when (eql c #\|)
              (setq bar-flag nil))
            (push c tmp)
                  
            ;(unless (eq c #\|) (error "#Q .. }#: misplaced |"))
            )
          ((eq c #\\) 
            (setq escape-flag t)
            (when (eq (car tmp) #\#) ;;文字リテラル#\における\を読み込んだ場合
              (push #\\ tmp)))
          ((eq c #\｜) (push #\| tmp))
          ((eq c #\") 
            (unread-char #\" stream)
            (let ((src-str (format nil "~S" (read stream t nil t))))
              (setq tmp (nconc (nreverse (coerce src-str 'list))
                               tmp))))
          ((eq c #\;) (do () ((eq #\Newline
                                  (read-char stream)))))
          (t 
            (push c tmp)
            (setq comma-flag (eq c #\.))
            (setq bar-flag (eq c #\|))))))


(cluw:register-optional-reader :xi '<register-readers>)
(cluw:register-optional-reader :clap '<register-readers>)
