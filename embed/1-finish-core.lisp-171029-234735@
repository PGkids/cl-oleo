;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; 作業用空間 Q
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(defpackage :Q 
;  (:use :cl :cluw :xi.core))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(use-package :xi.core :clap.qspace)


(let* ((*readtable* xi.core:*qi-readtable*))
  (set-dispatch-macro-character 
   #\# #\{ 
   #'cluw:|#{-READER|))

(DEFUN XI.CORE:QILOAD (filename)
  (let ((*package* (find-package :Q))
        (*readtable* xi.core:*qi-readtable*))
    (xi.core:|load| filename)))


(in-package :xi.core)

(defun %load% (V1)
  (setq |*tempsigs*| nil)
  (|initialise_environment|)
  (LET (*V-STACK*
        (|*inferences*| 0))
    (|load-help| |*tc*| (THE LIST V1)))
  ;;(IF (EQ |*tc*| '|true|) 
  ;;  (|output| "~%~%typechecked in ~A inferences" (THE NUMBER (|inferences| '_))))
  ;;(TERPRI)
  ;;|loaded|
  )

(defun %local-intern-needed-p% (s &key allow-string)
  (when (and (symbolp s)
             (not (eq (symbol-package s) 
                      (cluw:memoized (find-package :Q)))))
    (return-from %local-intern-needed-p% nil))

  (unless (or (symbolp s) 
              (and (stringp s) 
                   allow-string))
    (return-from %local-intern-needed-p% nil))

  (let* ((name (if (stringp s) 
                 s 
                 (symbol-name s)))
         (c (char name 0)))
    (or (upper-case-p c)
        (member c '(#\~ #\* #\+ #\< #\%))      
        (every (lambda (sym) (eq sym #\=)) name)
        (and (eq c #\_)
             (not (string= name "_"))))))

(defun %trans% (x)
  (cond ((symbolp x)
          (if (%local-intern-needed-p% x)
            (let ((c (char (symbol-name x) 0)))
              (if (eq c #\~)
                (let* ((upcased (intern 
                                 (string-upcase (coerce (cdr (coerce (symbol-name x) 
                                                                     'list)) 
                                                        'string))))
                       (qi-name (get upcased '<qi-name>)))
                  (unless qi-name (error "Xi.Core: ~A is not declared for Qi" x))
                  qi-name)
                (intern (symbol-name x))))
            x))
        ((atom x) x)
        (t (do ((cur x (cdr cur))
                tmp)
               ((atom cur)
                (let ((result (nreverse tmp)))
                  (setf (cdr (last result)) (%trans% cur))
                  result)
                )
             (push (%trans% (car cur)) tmp)))))

(defun %need-trans-p% (x)
  (cond ((symbolp x) (%local-intern-needed-p% x))
        ((atom x) nil)
        (t (do ((cur x (cdr cur)))
               ((atom cur)
                (%need-trans-p% cur))                
             (when (%need-trans-p% (car cur))
               (return t))))))


;(SETF (READTABLE-CASE *READTABLE*) :UPCASE)

;(xi.core::save)
;#-(OR ALLEGRO LISPWORKS) (quit)


(defmacro declare-for-qi (lisp-name qi-signature)
  (let* ((qi-name (if (get lisp-name '<qi-name>)
                    (get lisp-name '<qi-name>)
                    (setf (get lisp-name '<qi-name>)
                            (gensym (string-concat "qi;" (symbol-name lisp-name))))))
         (arity (count '~--> qi-signature))
         (tmp-vars (do ((tmp nil (push (gensym) tmp))
                        (n arity (1- n)))
                       ((zerop n)
                        tmp))))

    `(progn
      (defun ,qi-name ,tmp-vars (,lisp-name ,@tmp-vars))
      (define-compiler-macro ,qi-name ,tmp-vars (list ',lisp-name ,@tmp-vars))
      (~declare ',qi-name ',qi-signature)
      ',lisp-name)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(defun <register-readers> ()
  ;; Qiパッケージへのシンボルのインターン
  ;; ~fooBar は USER::|fooBar|のショートカットとなる
  ;; * < % で始まる長さ１以上シンボル、及び、_で始まる長さ２以上のシンボルは
  ;; ローカルなパッケージ（呼び出し元パッケージ）にインターンされる
  (set-macro-character
   #\~
   (lambda (stream char1)
     (declare (ignore char1))

     (let (result
           (cur-pkg *package*))
       (let* ((*package* (cluw:memoized (find-package :Q)))
              (*readtable* XI.CORE:*QI-READTABLE*)
              (src (read stream t nil t)))
         (setf result (if (XI.CORE::%need-trans-p% src)
                        (let ((*package* cur-pkg))
                          (XI.CORE::%trans% src))
                        src)))
       result)))


  )

;(SETF (READTABLE-CASE *READTABLE*) :UPCASE)

;; (\リーダの定義

(defun qi-reader (stream &key separated-comma type-check)
  (do (c 
       tmp
       escape-flag
       comma-flag
       bar-flag
       end-flag)
      (end-flag
       (let* ((chars (nreverse (cdr tmp)))
              (parsed (let ((*package* (find-package :Q))
                            (*readtable* xi.core:*qi-readtable*)
                            (errstr "Xi.Core: parse failure: ~%~%~{~C~} ..."))
                        (XI.CORE:|compile| 'XI.CORE::|<st_input>| chars errstr)))
                                        ;`(progn ,@(mapcar (lambda (x) `(XI.CORE::|eval| ',x))
                                        ;                  parsed))))
              (form (if (XI.CORE::%need-trans-p% parsed)
                      `(XI.CORE::%load% ',(XI.CORE::%trans% parsed))
                      `(XI.CORE::%load% ',parsed))))
         (if type-check
           `(let ((xi.core::|*tc*| ',type-check)) ,form)
           form)))
    
    (unless (characterp (setq c (read-char stream)))
      (error "Xi.Core: unexpected end of stream"))
    
    (when comma-flag
      (unless (eq c #\))
        (setq comma-flag nil)))

    (cond (comma-flag
            (setq end-flag t))
          (escape-flag
            (setq escape-flag nil)
            (push c tmp))
          (bar-flag
            (setq bar-flag nil)
            (unless (eq c #\|)
              (error "#Q .. }#: misplaced |")))
          ((eq c #\\) 
            (setq escape-flag t)
            (when (eq (car tmp) #\#) ;;文字リテラル#\における\を読み込んだ場合
              (push #\\ tmp)))
          ((and (eq c #\:) 
                separated-comma)
            (setq tmp (nconc (list #\Space #\: #\Space) tmp)))
          ((eq c #\') (setq tmp (nconc (list #\Space #\, #\Space) tmp))) ;HACK
          ((eq c #\`) (setq tmp (nconc (list #\Space #\| #\Space) tmp))) ;HACK
          ((eq c #\：) (setq tmp (nconc (list #\Space #\: #\Space) tmp))) ;OBSOLETE
          ((eq c #\⇒) (setq tmp (nconc (coerce " ___ " 'list) tmp)))
          ((eq c #\⇔) (setq tmp (nconc (coerce " === " 'list) tmp)))
          ((eq c #\＝) (setq tmp (nconc (coerce " >- " 'list) tmp)))
          ((eq c #\≒) (setq tmp (nconc (coerce " -< " 'list) tmp)))
          ((eq c #\→) (setq tmp (nconc (coerce " >-- " 'list) tmp)))
          ((eq c #\；) (push #\; tmp))
          ((eq c #\｜) (push #\| tmp))
          ((eq c #\") 
            (unread-char #\" stream)
            (let ((src-str (format nil "~S" (read stream t nil t))))
              (setq tmp (nconc (nreverse (coerce src-str 'list))
                               tmp))))
          ((eq c #\;) (do () ((eq #\Newline
                                  (read-char stream)))))
          (t 
            (push c tmp)
            (setq comma-flag (eq c #\.))
            (setq bar-flag (eq c #\|))))))

(cluw:define-lpar-backslash-reader "XI" (stream)
  (qi-reader stream :separated-comma t))

(cluw:define-lpar-backslash-reader "XI+" (stream)
  (qi-reader stream :separated-comma t :type-check 'xi.core:|true|))

(cluw:define-lpar-backslash-reader "XI-" (stream)
  (qi-reader stream :separated-comma t :type-check 'xi.core:|false|))

(cluw:define-lpar-backslash-reader "X-YACC" (stream)
  (qi-reader stream :type-check 'xi.core:|false|))


(cluw:define-lpar-backslash-reader "X-PROLOG" (stream)
  (do (c 
       tmp
       escape-flag
       comma-flag
       bar-flag
       end-flag)
      (end-flag
       (let* ((chars (nreverse (cdr tmp)))
              (parsed (let ((*package* (find-package :Q))
                            (*readtable* xi.core:*qi-readtable*)
                            (errstr "syntax error in Prolog(Qi) here: ~%~%~{~C~}"))
                        (XI.CORE:|compile| 'XI.CORE::|<horn_clauses>| chars errstr))))
         (if (XI.CORE::%need-trans-p% parsed)
           `(XI.CORE:|s-prolog| ',(XI.CORE::%trans% parsed))
           `(XI.CORE:|s-prolog| ',parsed))))    
    
    (unless (characterp (setq c (read-char stream)))
      (error "Xi.Core: unexpected end of stream"))

    (when comma-flag
      (unless (eq c #\))
        (setq comma-flag nil)))

    (cond (comma-flag
            (setq end-flag t))
          (escape-flag
            (setq escape-flag nil)
            (push c tmp))
          (bar-flag
            (setq bar-flag nil)
            (unless (eq c #\|)
              (error "#Q .. }#: misplaced |")))
          ((eq c #\\) 
            (setq escape-flag t)
            (when (eq (car tmp) #\#) ;;文字リテラル#\における\を読み込んだ場合
              (push #\\ tmp)))
          ((eq c #\｜) (push #\| tmp))
          ((eq c #\") 
            (unread-char #\" stream)
            (let ((src-str (format nil "~S" (read stream t nil t))))
              (setq tmp (nconc (nreverse (coerce src-str 'list))
                               tmp))))
          ((eq c #\;) (do () ((eq #\Newline
                                  (read-char stream)))))
          (t 
            (push c tmp)
            (setq comma-flag (eq c #\.))
            (setq bar-flag (eq c #\|))))))


(cluw:register-optional-reader :xi '<register-readers>)
